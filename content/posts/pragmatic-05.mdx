---
date: 2022-03-26
title: 실용주의 프로그래머 05
subtitle: 노마드코더 북클럽 실용주의 프로그래머 1기에 참여하며 남기는 기록
category: reading
tags: ['노마드 개발자 북클럽', '실용주의 프로그래머']
slug: /pragmatic-programmer-05
---

> [노마드코더 북클럽 실용주의 프로그래머](https://nomadcoders.co/pragmatic-programmer?utm_source=Nomad+Academy&utm_campaign=b21db3e0fc-EMAIL_CAMPAIGN_2022_03_11&utm_medium=email&utm_term=0_4313d957c9-b21db3e0fc-44797189&mc_cid=b21db3e0fc&mc_eid=ada1dd7049) 1기에 참여하며 남기는 기록

<br />

## 📖 읽은 범위

5장. 구부러지거나 부러지거나

---

## 📍 TIL 3줄 요약

- 현대의 빠른 변화 속도를 따라가려면 가능한 한 느슨하고 유연한 코드를 작성해야 한다.
- 되돌릴 수 있는 의사 결정을 내리는 구체적인 방법들을 실천하면 불확실한 세상에서도 유연성과 적응력을 잃지 않을 것이다.
- 결합도를 낮추는 코드를 작성하는 것이 핵심이다.

---

## ✏️ 기억하고 싶은 내용

### 결합도 줄이기

- 소프트웨어의 구조는 유연해야 한다. 그리고 유연하려면 각각의 부품이 다른 부품에 가능한 한 조금만 연결되어야 한다.
- 결합은 두 개의 코드 조각이 무언가를 공유하면 언제나 일어날 수 있다. 코드에서 나타나는 다음과 같은 결합의 증상을 놓치지 않도록 주의해야 한다.
  > 1. 관계없는 모듈이나 라이브러리 간의 희한한 의존 관계
  > 2. 한 모듈의 '간단한' 수정이 이와 관계없는 모듈을 통해 시스템 전역으로 퍼져 나가거나 시스템의 다른 곳에서 무언가를 깨뜨리는 경우
  > 3. 개발자가 수정하는 부분이 시스템에 어떤 영향을 미칠지 몰라 코드의 수정을 두려워하는 경우
  > 4. 변경 사항에 누가 영향을 받았는지 파악하고 있는 사람이 없어서 결국 모든 사람이 참석해야 하는 회의

#### 대표적인 결합 패턴 세 가지

##### 1. 열차 사고 - 연쇄 메서드 호출

- 열차 사고란 기차의 모든 객차가 서로 연결되어 있듯이 메서드나 속성들이 모두 연결되어 있는 코드를 말한다.
- `묻지 말고 말하라 (Tell, Don't Ask, TDA)`
  - 이 원칙은 다른 객체의 내부 상태에 따라 판단을 내리고 그 객체를 갱신해서는 안된다는 것이다. 객체의 내부 상태를 묻는 것으로 인하여 캡슐화의 장점은 완전히 사라지고, 또 그 과정에서 구현에 대한 지식이 여기저기로 퍼져 버린다.
  - 하지만 TDA는 자연법칙이 아니다. 문제를 알아볼 수 있게 도와주는 패턴일 뿐이다.
- `데메테르 법칙 (Law of Demeter, LoD)`
  - 데메테르라는 프로젝트를 수행하는 도중 개발자들에게 보다 깨끗하고 결합도가 낮은 함수를 작성하는 방법을 알려주기 위해 만든 일련의 지침.
- `메서드 호출을 엮지 말라`
  - 무언가에 접근할 때 .을 딱 하나만 쓰려고 노력해 보라. '무언가에 접근'한다는 건 중간 변수를 사용하는 경우까지 포함해야 한다. (...) 점 하나 규칙에는 큰 예외가 하나 있다. 엮는 것들이 절대로 바뀌지 않늘 것 같다면 이 규칙을 지키지 않아도 된다. 사실 여러분의 애플리케이션에 있는 것은 모두 바뀌리라 생각해야 한다.

##### 2. 글로벌화 : 정적인(static) 것의 위험함

- 전역 데이터는 여러 가지 방법으로 코드의 결합도를 높인다. 전역 데이터의 구현을 변경할 때 시스템 코드 전체에 영향을 줄 수 있음은 분명하다.

- 전역데이터는 코드를 떼어 내는 경우에도 문제를 만든다.
- 코드를 재사용할 수 있게 하려면 깨끗한 인터페이스를 만들고 나머지 코드와의 결합을 없애야 한다.

##### 싱글턴도 전역 데이터다

- 여러분의 코드에 있는 것이 싱글턴뿐이더라도, 외부로 노출된 인스턴스 변수가 잔뜩 있는 싱글턴은 여전히 전역 데이터이다. 그저 이름이 좀 길어졌을 뿐.
- 싱글턴에서 모든 데이터를 메서드 안으로 숨기면 그나마 낫긴 하다. 하지만 설정 데이터를 딱 한 벌만 가지고 있는 것에는 변함이 없다.

##### 외부 리소스도 전역 데이터다

- 수정 가능한 외부 리소스는 모두 전역 데이터다. 해법은 반드시 이 리소스들을 여러분이 작성하는 코드로 모두 감싸는 것이다.
- 전역적이어야 할 만큼 중요하다면 API로 감싸라.

#### 3. 상속

<br />

### 실세계를 갖고 저글링하기

#### 이벤트

이벤트는 무언가 정보가 있다는 것을 의미한다. 정보는 사용자가 버튼을 클릭하거나, 주가 정보가 갱신될 때처럼 외부에서 올 수 있다. 정보는 내부에서 생길 수도 있다. 계산 결과가 나왔거나, 검색 작업이 끝났을 수도 있고, 리스트에서 다음 원소를 가져오는 것처럼 사소한 것일 수도 있다.

어디에서 온 것이든 애플리케이션을 이런 이벤트에 반응하도록, 그리고 그에 기반해서 하는 일을 조절하도록 만들면, 진짜 세상에서 더 잘 작동하는 애플리케이션이 탄생할 것이다. 사용자들은 애플리케이션의 상호 작용이 더 원활하다고 느낄 것이고 애플리케이션 자체는 리소스를 더 효율적으로 사용할 것이다.

어떻게 이벤트에 잘 반응하는 애플리케이션을 만들 수 있을까? 우리를 도와줄 네 가지 전략을 살펴보자.

##### 1. 유한 상태 기계

##### 2. 감시자(observer) 패턴

- 이벤트를 발생시키는 쪽인 감시 대상(observable)과 이런 이벤트에 관심이 있는 클라이언트인 감시자(observer)로 이루어진다.
- 감시자는 자신이 관심 있는 이벤트를 감시 대상에 등록한다. 나중에 해당 이벤트가 발생하면 감시 대상은 등록된 감시자 목록을 보면서 함수들을 일일이 호출한다.
- 문제는 모든 감시자가 감시 대상에 등록을 해야하기 때문에 결합이 생긴다는 점이다. 더군다가 일반적으로 감시 대상이 콜백을 직접 호출하도록 구현하기 때문에 이 부분이 성능 병목이 될 수 있다.

##### 3. 게시 구독 (Pub-Sub)

- 감시자 패턴을 일반화한 것이다. 동시에 감시자 모델의 결합도를 높이는 문제와 성능 문제도 해결한다.
- 게시-구독 모델에는 게시자(publisher)와 구독자(subscriber)가 있고, 이들은 채널(channel)로 연결된다.
- 감시자 패턴과 다르게 게시자와 구독자 사이의 통신은 여러분의 코드 밖에서 일어난다. 아마 비동기적으로 이루어질 것이다.
- 게시-구독 모델은 추가적인 결합 없이 비동기 이벤트 처리를 구현하기에 아주 좋은 기술이다.
- 단점은 게시-구독 모델을 아주 많이 사용하는 시스템에서는 현재 어떤 일이 벌어지고 있는지 파악하기 힘들다는 것이다.

##### 4. 반응형 프로그래밍과 스트림

- 값이 바뀌면 그 값을 사용하는 다른 값이 '반응하는(react)' 것이다.
- 정말 강력한 추상화다. 더 이상 시간을 어떻게 관리할지 고민할 필요가 없다. 이벤트 스트림은 동기적 처리와 비동기적 처리를 하나의 편리한 공통 API로 감싸서 통합한다.

이벤트는 모든 곳에 있다. 이벤트가 어디서 발생하든 이벤트를 중심으로 공들여 만든 코드는 일직선으로 수행되는 코드보다 더 잘 반응하고 결합도가 더 낮다.

<br />

### 변환 프로그래밍

- 프로그램이란 입력을 출력으로 바꾸는 것이라는 사고방식으로 돌아갈 필요가 있다.
- 파이프라인을 사용하면 자동으로 데이터 변환의 관점에서 생각하게 된다.
- 변환 프로그래밍이 왜 그리 대단한가? 요구 사항을 달성하기 위해 필요한 것은 하나로 연결된 변환들뿐이다. 이보다 글처럼 읽기 쉬운 코드는 만들기 어려울 것이다.
- 하지만 더 깊은 의미도 있다. 변환 모델에서는 데이터를 거대한 강으로, 흐름으로 생각한다. 우리 애플리케이션이 입력을 출력으로 바꾸어 나가는 진행 상황을 데이터로 자유롭게 표현할 수 있다. 이 말인즉슨 **결합을 대폭 줄일 수 있다**는 것이다. 어떤 함수든 매개 변수가 다른 함수의 출력 결과와 맞기만 하면 어디서나 사용하고 또 재사용할 수 있다.

<br />

### 상속세

#### 코드를 공유하기 위해 상속을 쓸 때의 문제

상속도 일종의 결합이다. 자식 클래스가 부모 클래스, 부모의 부모, 또 그 부모에게 연결되는 것은 물론이요, 자식 클래스를 사용하는 코드도 이 클래의 모든 조상과 얽히게 된다.

#### 타입을 정의하기 위해 상속을 쓸 때의 문제

복잡한 클래스 계층도는 애플리케이션을 더 취약하게 만든다. 변경사항이 위나 아래로 여러 단계에 걸쳐 영향을 미칠 수 있기 때문이다. 더 나쁜 것은 다중 상속 문제다.

#### 더는 상속을 쓸 필요가 없게 해 주는 세 가지 기법

1. 인터페이스와 프로토콜
2. 위임
3. 믹스인과 트레이트

---

## 💭 소감

- 결합도를 줄일 수 있는 구체적인 방법들이 흥미로웠다. 특히 변환 프로그래밍에 대하 내용을 읽으면서 함수형 프로그래밍을 제대로 공부하고 프로젝트에 적용해보고 싶다는 생각이 많이 들었다.
- 실무에서 많이 사용하고 있는 React, Redux가 '반응형 프로그래밍'의 구현체라는걸 깨달았다.
