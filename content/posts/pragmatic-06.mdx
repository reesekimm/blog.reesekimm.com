---
date: 2022-03-28
title: 실용주의 프로그래머 06
subtitle: 노마드코더 북클럽 실용주의 프로그래머 1기에 참여하며 남기는 기록
category: reading
tags: ['노마드 개발자 북클럽', '실용주의 프로그래머']
slug: /pragmatic-programmer-06
---

> [노마드코더 북클럽 실용주의 프로그래머](https://nomadcoders.co/pragmatic-programmer?utm_source=Nomad+Academy&utm_campaign=b21db3e0fc-EMAIL_CAMPAIGN_2022_03_11&utm_medium=email&utm_term=0_4313d957c9-b21db3e0fc-44797189&mc_cid=b21db3e0fc&mc_eid=ada1dd7049) 1기에 참여하며 남기는 기록

<br />

## 📖 읽은 범위

6장. 동시성

---

## 📍 TIL 3줄 요약

- 실제 세상을 다루는 대부분의 애플리케이션들은 동시성 이슈를 피할 수 없다.
- 동시성을 확보해서 시간이나 순서에 의존하는 시간적 결합을 끊으면 분석하기 더 쉽고 응답속도도 더 빠르며 더 안정적인 시스템을 만들 수 있다.
- 동시성 이슈의 가장 큰 문제는 '공유 상태'에서 발생한다. 우리는 액터 모델이나 칠판 시스템을 통해 시간적 결합을 대폭 줄일 수 있다.

---

## ✏️ 기억하고 싶은 내용

- `동시성(concurrency)`은 둘 이상의 코드 조각이 실행될 때 동시에 실행 중인 것처럼 행동하는 것이다. (소프트웨어 동작 방식)
- `병렬성(parallelism)`이란 실제로 동시에 실행되는 것이다. (하드웨어가 하는 것)

개발자들은 코드 간의 결합에 대하여 자주 이야기한다. 주로 입에 오르는것은 의존성, 그리고 이런 의존성이 어떻게 코드를 바꾸기 힘들게 하는지다. 그런데 또 다른 형태의 결합이 있다. `시간적 결합(temporal coupling)`은 당면한 문제 해결에 꼭 필요하지 않은 일 처리 순서를 코드가 강제할 때 생긴다.

<br />

동시성이나 병렬성을 지원하는 코드를 쓰는건 왜 그렇게 어려울까?

1. 우리가 프로그래밍을 순차적 시스템으로 배워서다.
2. 우리가 쓰는 언어의 기능이 순차적으로 사용할 때는 비교적 안전하지만, 동시에 두 가지 일이 일어날 수 있으면 골칫거리로 변해서다.

**가장 큰 문제는 `공유상태(shared state)`다.** 단순히 전역 변수만을 이야기하는 것이 아니다. 둘 이상의 코드 뭉치가 하나의 변경 가능한 데이터를 참조하고 있다면 공유 상태가 존재하는 것이다.

<br />

### 시간적 결합 깨트리기

- 많은 프로젝트에서 설계 과정의 일환으로 애플리케이션의 작업 흐름을 모델화하고 분석하는 작업이 필요하다. 우리는 동시에 일어나도 되는 게 뭐고, 반드시 순서대로 일어나야 하는 건 어떤 것인지 찾아내길 원한다.
- `활동 다이어그램(activity diagram)` 같은 표기법을 사용해서 작업 흐름을 기록하는 것이 한 방법이다. 활동 다이어그램을 사용하면 동시에 수행할 수 있는데도 아직 동시에 하고있지 않은 활동들을 찾아내서 병렬성을 극대화할 수 있다.
- 하지만 활동 동시에 작업할 수 있는 부분들을 보여 준다. 하지만 진짜로 동시에 하는 것이 좋은지는 알려주지 않는다. 그래서 설계가 필요하다.
- 동시성을 고려한 설계를 통해 시간이 걸리지만 우리 코드가 아닌 곳에서 시간이 걸리는 활동을 찾아야 한다. 데이터베이스를 조회할 때나 외부 서비스에 접근할 때, 사용자 입력을 기다릴 때 같이 우리 프로그램이 다른 작업이 끝나기를 기다려야 하는 상황 말이다. 이런 순간이 바로 CPU가 손가락만 빨면서 기다리는 대신 좀 더 생산적인 일을 할 수 있는 기회다.

<br />

### 공유 상태는 틀린 상태

- 세마포어(semaphore)는 단순히 한 번에 한 사람만이 가질 수 있는 무언가다. 여러분은 세마포어를 만들어서 다른 리소스의 사용을 제어하는 데 쓸 수 있다.
- 세마포어를 획득한 쪽만이 원하는 리소스를 획득해서 원하는 작업을 수행할 수 있다.
- 블규칙한 실패는 동시성 문제인 경우가 많다.

<br />

### 액터와 프로세스

- `액터`는 자신만의 비공개 지역 상태(state)를 가진 독립적인 가상 처리 장치(virtual processor)다.
- `프로세스`는 본래 더 일반적인 가상 처리기로, 보통 운영 체제가 동시성을 지원하기 위하여 구현한다.

<br />

**액터는 언제나 동시성을 띤다.**

> - 액터를 관리하는 것이 하나도 없다.
> - 시스템이 저장하는 상태는 오직 메시지 그리고 각 액터의 지역 상태뿐이다.
> - 모든 메시지는 일방향이다.
> - 액터는 한 번에 하나의 메시지만 처리한다.

그 결과 액터들은 **아무것도 공유하지 않으면서 비동기적으로 동시에 실행된다**.

<br />

액터 모델에서는 동시성을 다루는 코드를 쓸 필요가 없다. 공유된 상태가 없기 때문이다. 명시적으로 처음부터 끝까지 '이걸 한 다음 저걸 하라'는 보드를 쓸 필요도 없다. 액터가 수신하는 메시지에 따라 알아서 실행되기 때문이다. 기반 아키텍처에 대하여 언급할 필요도 없다. 이렇게 구성된 컴포넌트들은 단일 프로세서든, 멀티 코어든, 여러 컴퓨터가 네트워크로 연결되어 있든 똑같이 잘 작동한다.

<br />

### 칠판

- 일종의 '자유방임주의'적 동시성이다.
- 각 형사는 독립된 프로세스, 에이전트, 액터 등과 같다. 누군가는 칠판에 수집한 사실을 붙이고, 누군가는 떼어 낸다. 사실을 조합하거나 처리할 수도 있고 더 많은 정보를 덧붙일 수도 있다. 칠판은 사람들이 서서히 결론에 도달하도록 돕는다.
- 칠판 시스템을 법적 요구사항을 캡슐화하는 규칙 엔진과 함께 사용하면 이러한 어려움을 우아하게 해결할 수 있다. 데이터의 도착 순서는 이제 상관없다. 어떤 사실이 칠판에 올라가면 적절한 규칙이 발동되도록 하면 된다. 결과에 대한 피드백도 마찬가지로 쉽게 다룰 수 있다. 어떤 규칙에서 나온 것이든 그 결과를 다시 칠판에 올려서 다른 규칙들이 발동되도록 하면 된다.

---

## 💭 소감

- _'소프트웨어 아키택처에서 시간이라는 측면은 자주 무시된다. 우리가 신경쓰는 유일한 시간은 일정뿐이다.'_ 이 구절이 인상깊었다. 나역시 개발을 하면서 소프트웨어의 설계 요소로서의 시간은 크게 고민을 해보지 않았기 때문이다.
- 프론트엔드단에서 '시간이 걸리지만 우리코드가 아닌 곳에서 시간이 걸리는 활동'이라면 무엇이 있을까? 주로 사용자와의 인터랙션에서 발생하는 순간이 될텐데..
- 액터, 프로세스, 칠판에 대한 개념은 처음 접해서 생소하기도 하고 구현체 없이 이해하기가 좀 어려웠다.
